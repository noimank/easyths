# QuantTrader 开发指南

## 概述

QuantTrader 是一个基于插件架构的同花顺交易自动化系统。本文档为开发者提供系统架构说明、扩展开发方法以及内部接口使用指南。

## 系统架构

### 核心组件

1. **FastAPI Web服务**: 提供REST API接口
2. **操作队列**: 管理交易操作的串行执行
3. **自动化器**: 通过pywinauto控制同花顺客户端
4. **插件系统**: 支持扩展新的交易操作
5. **OCR服务**: 识别客户端界面文字（可选）

### 目录结构

```
src/
├── api/                    # API层
│   ├── routes/            # 路由定义
│   ├── dependencies/      # 依赖注入
│   └── middleware/        # 中间件
├── automation/            # 自动化层
│   ├── operations/        # 操作插件
│   ├── base_operation.py  # 基础操作类
│   ├── operation_manager.py # 插件管理器
│   └── tonghuashun_automator.py # 自动化器
├── core/                  # 核心组件
│   ├── operation_queue.py # 操作队列
│   └── ocr_service.py     # OCR服务
├── models/                # 数据模型
└── utils/                 # 工具函数
```

## 开发新的操作插件

### 1. 创建操作类

所有操作插件必须继承 `BaseOperation` 基类：

```python
from easyths.automation.base_operation import BaseOperation, register_operation
from easyths.models.operations import PluginMetadata, OperationResult

@register_operation
class MyOperation(BaseOperation):
    """自定义操作示例"""

    def _get_metadata(self) -> PluginMetadata:
        """返回操作元数据"""
        return PluginMetadata(
            name="MyOperation",
            version="1.0.0",
            description="我的自定义操作",
            author="your_name",
            operation_name="my_operation",
            parameters={
                "param1": {
                    "type": "string",
                    "required": True,
                    "description": "参数1说明"
                },
                "param2": {
                    "type": "integer",
                    "required": False,
                    "default": 100,
                    "description": "参数2说明"
                }
            }
        )

    async def validate(self, params: Dict[str, Any]) -> bool:
        """验证输入参数"""
        try:
            # 检查必需参数
            if "param1" not in params:
                self.logger.error("缺少必需参数 param1")
                return False

            # 参数验证逻辑
            if not isinstance(params["param1"], str):
                self.logger.error("param1 必须是字符串")
                return False

            self.logger.info("参数验证通过")
            return True

        except Exception as e:
            self.logger.exception("参数验证异常", error=str(e))
            return False

    async def execute(self, params: Dict[str, Any]) -> OperationResult:
        """执行操作"""
        try:
            # 获取参数
            param1 = params["param1"]
            param2 = params.get("param2", 100)

            self.logger.info(
                f"执行自定义操作",
                param1=param1,
                param2=param2
            )

            # 实现具体的操作逻辑
            # 例如：控制同花顺客户端、查询数据等

            # 返回结果
            result_data = {
                "operation": "my_operation",
                "param1": param1,
                "param2": param2,
                "success": True
            }

            return OperationResult(
                success=True,
                data=result_data
            )

        except Exception as e:
            error_msg = f"操作执行异常: {str(e)}"
            self.logger.exception(error_msg)
            return OperationResult(
                success=False,
                error=error_msg
            )
```

### 2. 注册操作

使用 `@register_operation` 装饰器自动注册操作。注册后，操作可以通过API调用。

### 3. 使用自动化器

操作中可以使用 `self.automator` 访问同花顺自动化器：

```python
# 获取主窗口
main_window = self.automator.get_main_window()

# 获取控件
control = self.get_control(
    parent=main_window,
    class_name="Edit",
    control_id=0x408
)

# 设置文本
control.set_edit_text("文本内容")

# 模拟按键
control.type_keys("123456")

# 点击按钮
button = self.get_control(
    parent=main_window,
    class_name="Button",
    control_id=0x3EE
)
button.click()

# 切换左侧菜单
self.switch_left_menus(["查询[F4]", "资金股票"])
```

## 自动化器接口

### TonghuashunAutomator 类

主要的自动化控制类，提供以下功能：

```python
class TonghuashunAutomator:
    """同花顺自动化控制器"""

    def get_main_window(self):
        """获取主窗口对象"""

    async def is_connected(self):
        """检查是否已连接到同花顺客户端"""

    def get_control(self, parent=None, class_name=None, title=None, control_id=None):
        """获取指定控件"""

    def switch_left_menus(self, menu_path):
        """切换左侧菜单，如 ['查询[F4]', '资金股票']"""

    def is_exist_pop_dialog(self):
        """检查是否存在弹窗"""

    def get_pop_dialog_title(self):
        """获取弹窗标题"""

    def get_top_window(self):
        """获取顶层窗口"""
```

### 控件操作方法

```python
# 获取控件
edit_control = self.get_control(class_name="Edit", control_id=0x408)

# 设置文本
edit_control.set_edit_text("内容")

# 获取文本
text = edit_control.window_text()

# 模拟输入
edit_control.type_keys("123456")

# 点击
button.click()

# 双击
control.double_click()

# 右键点击
control.right_click()
```

## 队列系统

### OperationQueue 类

操作队列管理所有交易的串行执行：

```python
class OperationQueue:
    """操作队列"""

    async def put(self, operation: Operation) -> bool:
        """添加操作到队列"""

    async def cancel_operation(self, operation_id: str) -> bool:
        """取消操作"""

    async def retry_operation(self, operation_id: str) -> bool:
        """重试操作"""

    def get_operation(self, operation_id: str) -> Operation:
        """获取操作对象"""

    def get_queue_stats(self) -> Dict:
        """获取队列统计信息"""
```

### 操作生命周期

1. **PENDING**: 操作创建
2. **QUEUED**: 加入队列
3. **RUNNING**: 正在执行
4. **COMPLETED**: 执行成功
5. **FAILED**: 执行失败
6. **CANCELLED**: 被取消
7. **RETRYING**: 重试中

## OCR服务集成

系统支持使用OCR识别同花顺客户端的文字：

```python
from easyths.core.ocr_service import get_ocr_service

# 获取OCR服务
ocr_service = get_ocr_service()

# 识别截图中的文字
text = ocr_service.recognize_text(image_path)

# 识别指定区域
text = ocr_service.recognize_text_region(image_path, x, y, width, height)
```

## 日志系统

使用 structlog 进行结构化日志记录：

```python
import structlog

logger = structlog.get_logger(__name__)

# 记录日志
logger.info("操作开始", operation="buy", stock_code="000001")

# 带异常信息的日志
logger.exception("操作失败", operation="buy", error=exception)

# 在BaseOperation子类中使用
self.logger.info("执行操作", **params)
```

## 配置管理

通过环境变量进行配置：

```python
import os

# 读取配置
api_host = os.getenv("API_HOST", "0.0.0.0")
api_port = int(os.getenv("API_PORT", "8000"))
trading_app_path = os.getenv("TRADING_APP_PATH")

# 使用默认值
log_level = os.getenv("LOGGING_LEVEL", "INFO")
```

## 错误处理

### 最佳实践

1. **参数验证**: 在 `validate` 方法中严格验证输入参数
2. **异常捕获**: 在 `execute` 方法中捕获所有异常
3. **日志记录**: 记录关键操作和错误信息
4. **优雅失败**: 返回有意义的错误信息

```python
async def execute(self, params: Dict[str, Any]) -> OperationResult:
    try:
        # 参数验证（可选，因为validate已执行）
        if not self.validate(params):
            return OperationResult(
                success=False,
                error="参数验证失败"
            )

        # 执行操作
        result = self._do_operation(params)

        # 返回成功结果
        return OperationResult(
            success=True,
            data=result
        )

    except TimeoutError:
        error_msg = "操作超时"
        self.logger.error(error_msg)
        return OperationResult(success=False, error=error_msg)

    except Exception as e:
        error_msg = f"操作执行失败: {str(e)}"
        self.logger.exception(error_msg)
        return OperationResult(success=False, error=error_msg)
```

## 测试

### 单元测试示例

```python
import pytest
from unittest.mock import Mock, patch
from easyths.automation.operations.my_operation import MyOperation

@pytest.fixture
def mock_automator():
    automator = Mock()
    automator.get_main_window.return_value = Mock()
    return automator

@pytest.fixture
def my_operation(mock_automator):
    return MyOperation(automator=mock_automator)

@pytest.mark.asyncio
async def test_validate_success(my_operation):
    params = {"param1": "test_value"}
    result = await my_operation.validate(params)
    assert result is True

@pytest.mark.asyncio
async def test_validate_missing_param(my_operation):
    params = {}
    result = await my_operation.validate(params)
    assert result is False

@pytest.mark.asyncio
async def test_execute_success(my_operation):
    params = {"param1": "test", "param2": 100}
    result = await my_operation.execute(params)

    assert result.success is True
    assert result.data["operation"] == "my_operation"
```

## 部署

### 环境要求

- Python 3.8+
- Windows 10/11（用于pywinauto）
- 同花顺交易客户端

### 安装步骤

```bash
# 克隆代码
git clone https://github.com/your-repo/QuantTrader.git
cd QuantTrader

# 安装依赖
pip install -r requirements.txt

# 配置环境变量
cp .env.example .env
# 编辑 .env 文件

# 启动服务
python -m uvicorn src.main:app --reload
```

### Docker部署

```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

ENV PYTHONPATH=/app
ENV API_HOST=0.0.0.0
ENV API_PORT=8000

CMD ["python", "-m", "uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

## 性能优化

1. **异步操作**: 使用async/await提高并发性能
2. **连接池**: 复用数据库连接（如需要）
3. **缓存**: 缓存频繁查询的数据
4. **队列优化**: 合理设置队列大小和批处理大小

## 安全考虑

1. **API密钥**: 使用强密钥，定期更换
2. **参数验证**: 严格验证所有输入参数
3. **操作日志**: 记录所有操作审计日志
4. **权限控制**: 限制不同操作的权限

## 常见问题

### Q: 如何获取控件的ID？
A: 使用工具如Spy++或inspect.py查看窗口控件信息。

### Q: 操作超时怎么办？
A: 调整环境变量TRADING_TIMEOUT或增加重试次数。

### Q: 如何调试操作？
A: 查看日志文件logs/trading.log，使用DEBUG日志级别。

### Q: 支持其他券商客户端吗？
A: 目前仅支持同花顺，需要扩展自动化器以支持其他客户端。

## 贡献指南

1. Fork 项目
2. 创建特性分支
3. 提交改动
4. 推送到分支
5. 创建 Pull Request

请确保：
- 代码符合 PEP8 规范
- 添加适当的测试
- 更新相关文档